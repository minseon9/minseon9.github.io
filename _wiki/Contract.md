---
layout      : single
title       : 
summary     : 
date        : 2025-07-08 22:18:11 +0900
updated     : 2025-07-08 22:18:36 +0900
category    : 
tags        : 
toc         : true
public      : true
parent      : 
latex       : false
resource    : D22453CE-95B1-47C5-A923-AB9FEAEC5644
---
* TOC
{:toc}

#Contracts
To ease the derivation of a concrete design from an abstract design, e.g a
framework instantiation, some intermediate representation can be suitable,
i.e. a contract. A contract specify the collaboration between a number of
objects. The importance of object behaviour collaboration has been identi-
fied in [Wir90b] and contracts formalize these collaborations and behav-
ioural relationships.
Contracts have been proposed on various levels of abstraction and formal-
ism [Helm90], [Mey92].
The contracts by [Helm90] specifies behavioural compositions in terms of:
the participating objects, the contractual obligations for each participant,
invariants to be maintained by the participants and the operations which
instantiate the contract. The behaviour of a participant is then specified by
its obligations. The contractual obligations consists of type obligations and
causal obligations. In the case of type obligations, the participant must sup-
port certain variables and external interface and, in the case of causal obliga-
tions, the participant must perform an ordered sequence of actions,
including sending messages to other participants.
The contracts proposed by Meyer [Mey92] are at a lower level of abstraction
than the one above, and they have been introduced into an object-oriented
programming language, Eiffel [Mey88]. A contract for a class describes the
conditions that an object must satisfy during its existence and the contract
also includes pre- and postconditions for each class operation. The precon-
ditions must be satisfied by the client of the object otherwise the operation
will not be performed. If the precondition is satisfied, the operation will per-
form its task and it will also guarantee that the defined postconditions for the
operations will be true. Here, the contract idea is a way to more formally
specify the division of responsibilities between the server class and the cli-
ent class. An example of a software contract generated by the Eiffel system
for a put-operation on a Dictionary class [Man93] is presented below, figure
3.9.
A more informal description of the contract idea has been applied when
using the ET++ user interface framework [Wei89] and when developing a
business modelling and reengineering prototype environment [Laj94]. The
contract template used is presented in figure 3.10.
70
Framework Development
The advantages of using contracts when developing object-oriented frame-
works are [Laj94]:
• A vocabulary is established which helps the application developers to
communicate with each other when using the framework.
• Identification of application-specific classes, variables, methods, and
hooks for customization, all which are necessary for identifying, main-
taining and implementing a specific behaviour are provided to the
application developer.
• Better understanding of existing design patterns in the framework, thus
improving the understanding of the overall framework.

class interface DICTIONARY [ ELEMENT ] feature ;
put( x: ELEMENT; key: STRING) is
-- insert x so it’s accessible through key
require
count <= capacity;
not key.empty
ensure
has(x);
item(key) = x;
count = old count + 1
... interface specifications of other features
invariant
0 <= count ; count <= capacity
end class interface - DICTIONARY
Figure 3.9: Example of a software contract [Man92]

이 부분 설명해줘
Contracts To ease the derivation of a concrete design from an abstract design, e.g a framework instantiation, some intermediate representation can be suitable, i.e. a contract. A contract specify the collaboration between a number of objects. The importance of object behaviour collaboration has been identi- fied in [Wir90b] and contracts formalize these collaborations and behav- ioural relationships. Contracts have been proposed on various levels of abstraction and formal- ism [Helm90], [Mey92]. The contracts by [Helm90] specifies behavioural compositions in terms of: the participating objects, the contractual obligations for each participant, invariants to be maintained by the participants and the operations which instantiate the contract. The behaviour of a participant is then specified by its obligations. The contractual obligations consists of type obligations and causal obligations. In the case of type obligations, the participant must sup- port certain variables and external interface and, in the case of causal obliga- tions, the participant must perform an ordered sequence of actions, including sending messages to other participants. The contracts proposed by Meyer [Mey92] are at a lower level of abstraction than the one above, and they have been introduced into an object-oriented programming language, Eiffel [Mey88]. A contract for a class describes the conditions that an object must satisfy during its existence and the contract also includes pre- and postconditions for each class operation. The precon- ditions must be satisfied by the client of the object otherwise the operation will not be performed. If the precondition is satisfied, the operation will per- form its task and it will also guarantee that the defined postconditions for the operations will be true. Here, the contract idea is a way to more formally specify the division of responsibilities between the server class and the cli- ent class. An example of a software contract generated by the Eiffel system for a put-operation on a Dictionary class [Man93] is presented below, figure 3.9. A more informal description of the contract idea has been applied when using the ET++ user interface framework [Wei89] and when developing a business modelling and reengineering prototype environment [Laj94]. The contract template used is presented in figure 3.10. 70 Framework Development The advantages of using contracts when developing object-oriented frame- works are [Laj94]: • A vocabulary is established which helps the application developers to communicate with each other when using the framework. • Identification of application-specific classes, variables, methods, and hooks for customization, all which are necessary for identifying, main- taining and implementing a specific behaviour are provided to the application developer. • Better understanding of existing design patterns in the framework, thus improving the understanding of the overall framework. class interface DICTIONARY [ ELEMENT ] feature ; put( x: ELEMENT; key: STRING) is -- insert x so it’s accessible through key require count <= capacity; not key.empty ensure has(x); item(key) = x; count = old count + 1 ... interface specifications of other features invariant 0 <= count ; count <= capacity end class interface - DICTIONARY Figure 3.9: Example of a software contract [Man92] 이 부분 설명해줘

아래는 질문하신 Contracts(계약)에 대한 원문 해설과 주요 개념 정리입니다.
Contracts(계약)이란?

Contracts는 추상적인 설계에서 구체적인 설계(예: 프레임워크 인스턴스화)로 내려갈 때, 그 중간 표현으로 사용될 수 있는 개념입니다.
계약은 여러 객체 간의 협력(collaboration)을 명확하게 지정합니다. 즉, 객체들이 어떻게 상호작용하며 각 객체가 무엇을 책임지는지 공식적으로 정의하는 역할을 합니다.
원문 요약 및 해설
1. 계약의 정의와 목적

    "To ease the derivation of a concrete design from an abstract design, e.g a framework instantiation, some intermediate representation can be suitable, i.e. a contract. A contract specify the collaboration between a number of objects. The importance of object behaviour collaboration has been identified in [Wir90b] and contracts formalize these collaborations and behavioural relationships."

    설명:
    추상 설계에서 구체 설계로 넘어갈 때, 객체들 간의 협력 관계를 공식화한 '계약'이 중간 단계로 유용합니다.
    계약은 객체들이 어떻게 상호작용해야 하는지, 각 객체가 어떤 행동을 해야 하는지 명확히 정의합니다.

2. 계약의 종류와 예시

    "Contracts have been proposed on various levels of abstraction and formalism [Helm90], [Mey92].
    The contracts by [Helm90] specifies behavioural compositions in terms of: the participating objects, the contractual obligations for each participant, invariants to be maintained by the participants and the operations which instantiate the contract. ... The contractual obligations consists of type obligations and causal obligations."

    설명:
    계약은 추상적 수준부터 구체적 수준까지 다양한 형태로 제안되어 왔습니다.

        Helm의 계약:

            참여 객체, 각 객체의 의무, 유지해야 할 불변식(invariant), 계약을 실현하는 연산(operation) 등으로 구성됩니다.

            type obligation: 특정 변수와 외부 인터페이스를 지원해야 함

            causal obligation: 특정 순서로 행동(메시지 전송 등)을 해야 함

    "The contracts proposed by Meyer [Mey92] are at a lower level of abstraction ... A contract for a class describes the conditions that an object must satisfy during its existence and the contract also includes pre- and postconditions for each class operation."

    설명:

        Meyer의 계약(Design by Contract, Eiffel 언어):

            클래스 수준에서 객체가 만족해야 할 조건, 각 연산의 사전조건(precondition)과 사후조건(postcondition)으로 구성됩니다.

            사전조건이 만족되지 않으면 연산이 실행되지 않고, 사후조건은 연산이 끝난 후 반드시 참이어야 합니다.

            서버 클래스와 클라이언트 클래스 간 책임 분담을 명확히 합니다.

3. 계약의 예시

    "An example of a software contract generated by the Eiffel system for a put-operation on a Dictionary class [Man93] is presented below, figure 3.9."

text
class interface DICTIONARY [ ELEMENT ] feature ;
put( x: ELEMENT; key: STRING) is
-- insert x so it’s accessible through key
require
    count <= capacity;
    not key.empty
ensure
    has(x);
    item(key) = x;
    count = old count + 1
... interface specifications of other features
invariant
    0 <= count ; count <= capacity
end class interface - DICTIONARY

    설명:

        require는 사전조건(precondition),

        ensure는 사후조건(postcondition),

        invariant는 클래스가 항상 유지해야 할 불변식입니다.

4. 비공식적 계약 활용 예시

    "A more informal description of the contract idea has been applied when using the ET++ user interface framework [Wei89] and when developing a business modelling and reengineering prototype environment [Laj94]."

    설명:

        ET++ UI 프레임워크나 비즈니스 모델링 환경 등에서 비공식적으로도 계약 개념이 활용됨

5. 계약의 장점

    "The advantages of using contracts when developing object-oriented frameworks are [Laj94]:

    A vocabulary is established which helps the application developers to communicate with each other when using the framework.

    Identification of application-specific classes, variables, methods, and hooks for customization, all which are necessary for identifying, maintaining and implementing a specific behaviour are provided to the application developer.

    Better understanding of existing design patterns in the framework, thus improving the understanding of the overall framework."

    설명:

        공통 언어 제공: 프레임워크 사용자(개발자) 간 의사소통이 쉬워집니다.

        확장 포인트 명확화: 커스터마이징에 필요한 클래스, 변수, 메서드, 훅(hook) 등을 쉽게 식별할 수 있습니다.

        패턴 이해도 증진: 프레임워크 내 디자인 패턴과 전체 구조를 더 잘 이해할 수 있습니다.

요약

    **Contracts(계약)**는 객체 간 협력과 책임을 명확히 하고, 추상 설계에서 구체 설계로의 전환을 돕는 공식적/비공식적 규약입니다.

    대표적으로 Helm(행동 중심, 역할/의무/불변식 등)과 Meyer(Design by Contract, 사전/사후조건, 불변식) 방식이 있습니다.

    계약은 프레임워크 개발 시 커뮤니케이션, 커스터마이징, 패턴 이해 등에서 큰 장점을 제공합니다.

필요하다면, ET++ 프레임워크나 Eiffel 언어의 실제 계약 예시를 더 들어 설명해드릴 수도 있습니다!
contract라는 개념은 코드 상에서 사용하는거니 혹은 추상 클래스와 구상 클래스를 명확하게 표현하기 위한 개념적인 요소인거니 ?
프레임워크에서 예시도 들어줘
contract라는 개념은 코드 상에서 사용하는거니 혹은 추상 클래스와 구상 클래스를 명확하게 표현하기 위한 개념적인 요소인거니 ? 프레임워크에서 예시도 들어줘

좋은 질문입니다!
아래에서 "contract(계약)" 개념이 코드 상에서 사용되는지, 아니면 추상 클래스와 구상 클래스를 명확히 표현하기 위한 개념적인 요소인지 설명하고, 프레임워크에서 실제 예시도 들어드릴게요.
1. Contract(계약)의 의미
개념적 요소 vs. 코드 상 구현

**Contract(계약)**는

    개념적으로는 객체(또는 클래스) 사이의 협력, 책임, 의무, 상호작용 규칙을 명확히 정의하기 위한 설계상의 약속입니다.

    코드 상에서는 이 계약을 명시적으로 표현할 수 있는 언어적 장치(예: Eiffel의 Design by Contract), 또는 문서, 주석, 추상 메서드, 인터페이스, 어노테이션 등으로 구현할 수 있습니다.

1) 개념적 측면

    계약은 추상 클래스와 구상 클래스의 역할과 책임을 명확히 구분하기 위한 설계 도구입니다.

    예를 들어, 추상 클래스에서 "이 메서드는 반드시 오버라이드해서 구현해야 한다"는 요구사항이 계약의 일종입니다.

2) 코드 상 구현

    Eiffel 언어처럼 contract를 명시적으로 지원하는 언어에서는 require(precondition), ensure(postcondition), invariant 같은 키워드로 구현합니다.

    Java/C++/C# 등에서는 인터페이스, 추상 메서드, 주석, 어노테이션, 또는 테스트 코드로 계약을 실질적으로 표현합니다.

2. 프레임워크에서의 Contract 예시
(1) 개념적 예시

ET++ 프레임워크(C++ 기반 UI 프레임워크)

    ET++의 추상 클래스(예: EWindow)는 "draw()" 같은 메서드를 정의만 하고, 실제 동작은 서브클래스가 구현하도록 강제합니다.

    이때 "draw()는 반드시 구현되어야 하며, 호출될 때 윈도우를 그려야 한다"는 것이 계약입니다.

    실제 C++ 코드에는 pure virtual function(=0)으로 표현하지만, 문서나 주석에서 "이 메서드는 반드시 구현되어야 하며, 다음과 같은 동작을 보장해야 한다"는 설명이 붙습니다.

cpp
class EWindow {
public:
    virtual void draw() = 0; // 계약: 반드시 오버라이드해서 윈도우를 그릴 것
};

    여기서 contract는 코드(추상 메서드)와 문서(설명)가 합쳐진 형태로 존재합니다.

(2) 코드 상 구현 예시

Eiffel 언어의 Dictionary 예시
(논문 Figure 3.9 참고)

text
class interface DICTIONARY [ ELEMENT ] feature ;
put( x: ELEMENT; key: STRING) is
-- insert x so it’s accessible through key
require
    count <= capacity;    -- 사전조건: 용량 초과 금지
    not key.empty         -- 사전조건: 키는 비어있지 않아야 함
ensure
    has(x);               -- 사후조건: x가 들어있어야 함
    item(key) = x;        -- 사후조건: 해당 키로 x를 꺼낼 수 있어야 함
    count = old count + 1 -- 사후조건: 원소 개수 1 증가
invariant
    0 <= count ; count <= capacity -- 불변식: 항상 0 이상, capacity 이하
end class interface - DICTIONARY

    여기서 contract는 코드로 명확히 구현되어 있습니다.

(3) Java/Spring 프레임워크 예시

Spring Framework의 콜백 인터페이스

java
public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}

    계약:

        이 인터페이스를 구현한 클래스는 afterPropertiesSet()을 반드시 구현해야 하며, 이 메서드는 모든 의존성이 주입된 후 호출되어야 한다는 규칙(계약)이 있습니다.

        Spring 문서에 이 계약이 명확히 설명되어 있습니다.

3. 정리

    contract는 설계 단계에서는 "개념적 약속"이지만,
    실제 코드에서는 추상 메서드, 인터페이스, 명시적 contract(언어 지원), 문서/주석 등 다양한 방식으로 표현됩니다.

    프레임워크에서는 contract가 커스터마이징 포인트, 확장 지점, 객체 협력 규칙을 명확히 하여, 개발자들이 올바르게 프레임워크를 사용할 수 있게 합니다.

    예시:

        추상 메서드/인터페이스(ET++, Spring 등)

        Eiffel의 명시적 contract

        문서화된 규칙(ET++ 문서, Spring Javadoc 등)

추가 요약

    contract는 설계적 개념이자, 코드로도 표현 가능한 약속

    프레임워크에서 contract는 확장/커스터마이징 포인트와 객체 협력 규칙을 명확히 하는 데 필수

    코드 예시: 추상 메서드, 인터페이스, 명시적 contract, 문서 등

궁금한 프레임워크나 더 구체적인 예시가 필요하면 말씀해 주세요! 
